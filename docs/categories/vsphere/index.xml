<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vsphere on </title>
    <link>https://darrylcauldwell.github.io/categories/vsphere/</link>
    <description>Recent content in vsphere on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 30 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://darrylcauldwell.github.io/categories/vsphere/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>VMware Event Broker Appliance (VEBA) - Knative</title>
      <link>https://darrylcauldwell.github.io/post/veba-knative/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://darrylcauldwell.github.io/post/veba-knative/</guid>
      <description>
        
          &lt;p&gt;When I worked as an architect working with AWS I used event-driven automation with AWS Lambda to integrate distributed systems. This event-driven automation allowed me to put complex systems in place very simply. The VMware Event Broker Appliance (VEBA) aims to facilitate event-driven automation based on vCenter Server events.&lt;/p&gt;
&lt;h2 id=&#34;vmware-event-broker-appliance&#34;&gt;VMware Event Broker Appliance&lt;/h2&gt;
&lt;p&gt;VMware provides the VMware Event Broker Appliance as a &lt;a href=&#34;https://flings.vmware.com/vmware-event-broker-appliance&#34;&gt;fling&lt;/a&gt;. The &lt;a href=&#34;https://vmweventbroker.io/kb/architecture&#34;&gt;system architecture&lt;/a&gt; shows that the appliance is built on a Photon OS running Kubernetes with Contour acting as ingress controller. The event broker appliance is composed of two components an event router and a choice of event stream processor Knative, OpenFaaS or AWS EventBridge.&lt;/p&gt;
&lt;h3 id=&#34;knative-eventing-configuration&#34;&gt;Knative Eventing Configuration&lt;/h3&gt;
&lt;p&gt;Since getting engaged with the Kubernetes community it seemed the biggest barrier to entry for most people was complexity.  Knative looks to obfuscate some of that complexity and provide an abstraction that allows more focus on business functionality. It offers two core functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serving - Run serverless containers on Kubernetes&lt;/li&gt;
&lt;li&gt;Eventing - Universal subscription, delivery, and management of events&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Knative Eventing is composed of Knative Broker and Trigger objects which make it easy to filter events based on event attributes. A Broker provides a bucket of events which can be selected by attribute. It receives events and forwards them to subscribers defined by one or more matching Triggers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/veba-knative-broker-trigger-overview.svg&#34; alt=&#34;Broker Trigger Architecture&#34;&gt;&lt;/p&gt;
&lt;p&gt;The v0.6 default install generates configuration for binding to vCenter Server with embedded Knative eventing &amp;lsquo;config/event-router-config.yml&amp;rsquo;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;## SSH to appliance&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;cat config/event-router-config.yml&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;event-router.vmware.com/v1alpha1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;RouterConfig&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;router-config-knative&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;eventProcessor&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-knative&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;knative&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;knative&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;insecureSSL&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;encoding&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;binary&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;destination&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;ref&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;eventing.knative.dev/v1&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Broker&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;vmware-functions&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;eventProvider&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-vc-01&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;vcenter&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;vcenter&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;address&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;https://&amp;lt;MY VCENTER FQDN&amp;gt;/sdk&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;auth&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;basicAuth&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;password&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;MY PASSWORD&amp;gt;&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;username&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;administrator@vsphere.local&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;basic_auth&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;insecureSSL&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;checkpoint&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metricsProvider&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;default&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;bindAddress&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0.0.0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;8082&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-metrics&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;eventProcessor&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-knative&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;knative&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;knative&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;insecureSSL&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;encoding&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;binary&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;destination&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;ref&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;eventing.knative.dev/v1&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Broker&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;vmware-functions&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;consuming-example-knative-function&#34;&gt;Consuming Example Knative Function&lt;/h2&gt;
&lt;p&gt;The GitHub repository contains a folder containing &lt;a href=&#34;https://github.com/vmware-samples/vcenter-event-broker-appliance/tree/development/examples/knative&#34;&gt;example Knative functions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If we look at the example function which triggers each of each all events to Pod console. To achieve this it defines a Knative eventing resource which has an unfiltered trigger on the default broker and defines Service named &amp;lsquo;kn-ps-echo&amp;rsquo; as subscriber.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;eventing.knative.dev/v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Trigger&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-ps-echo-trigger&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-ui&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;broker&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;subscriber&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;ref&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;serving.knative.dev/v1&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Service&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kn-ps-echo&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To perform action the example defines a Knative servicing Service resource which calls container image. We can see the service definition pulls a container from the VMware public container registry named &amp;lsquo;kn-ps-echo&amp;rsquo; version 1.0.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;serving.knative.dev/v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Service&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;kn-ps-echo&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-ui&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;template&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;annotations&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;autoscaling.knative.dev/maxScale&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;autoscaling.knative.dev/minScale&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;projects.registry.vmware.com/veba/kn-ps-echo:1.0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Within the example folder is the Dockerfile used to create the container. We can see this defines a Powershell runtime environment with the &lt;a href=&#34;https://www.powershellgallery.com/packages/CloudEvents.Sdk&#34;&gt;CloudEvents SDK&lt;/a&gt; and &lt;a href=&#34;https://www.powershellgallery.com/packages/ThreadJob&#34;&gt;ThreadJob&lt;/a&gt; modules installed. When running the container executes server.ps1 which starts a CloudEvent HTTP listener and if we look within that it calls handler.ps1 which in this case is what outputs event contents.  Both of these Powershell scripts are copied into the container at point of creation.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; photon:3.0&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ENV&lt;/span&gt; TERM linux&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ENV&lt;/span&gt; PORT &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Set terminal. If we don&amp;#39;t do this, weird readline things happen.&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/usr/bin/pwsh&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; /etc/shells &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/bin/pwsh&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; /etc/shells &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    tdnf install -y powershell-7.0.3-2.ph3 unzip &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    pwsh -c &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Set-PSRepository -Name PSGallery -InstallationPolicy Trusted&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    find / -name &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;net45&amp;#34;&lt;/span&gt; | xargs rm -rf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    tdnf erase -y unzip &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;    tdnf clean all&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; pwsh  -Command &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Install-Module ThreadJob -Force -Confirm:$false&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; pwsh -Command &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Install-Module -Name CloudEvents.Sdk&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; server.ps1 ./&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; handler.ps1 handler.ps1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CMD&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pwsh&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./server.ps1&amp;#34;&lt;/span&gt;]&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To test the example we can first pull and execute the manifest file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;curl -O https://github.com/vmware-samples/vcenter-event-broker-appliance/blob/development/examples/knative/powershell/kn-ps-echo/function.yaml
kubectl apply --filename &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;.yaml --namespace vmware-functions

service.serving.knative.dev/kn-ps-echo created
trigger.eventing.knative.dev/kn-ps-echo-trigger created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We see the service and eventing resources are created and we can check the vmware-functions namespace to get the kn-ps-echo function pod names. There are two containers in the pod, the user-container runs the function so we can follow its logs and see the flow of vCenter events being echo&amp;rsquo;d.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl get pods --namespace vmware-functions

NAME                                             READY   STATUS    RESTARTS   AGE
default-broker-ingress-5c98bf68bc-whmj4          1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          4d6h
kn-ps-echo-00001-deployment-6c9f77855c-ddz8w     2/2     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          18m
kn-ps-echo-trigger-dispatcher-7bc8f78d48-5cwc7   1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          18m
sockeye-65697bdfc4-n8ght                         1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          4d6h
sockeye-trigger-dispatcher-5fff8567fc-9v74l      1/1     Running   &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;          4d6h

kubectl logs --namespace vmware-functions kn-ps-echo-00001-deployment-6c9f77855c-ddz8w user-container --follow

Server start listening on &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://*:8080/&amp;#39;&lt;/span&gt;
Cloud Event
  Source: https://vcenter.cork.local/sdk
  Type: com.vmware.event.router/event
  Subject: UserLogoutSessionEvent
  Id: b2cb5b99-baf2-4b0b-93e7-33795e56ec88
CloudEvent Data:



Cloud Event
  Source: https://vcenter.cork.local/sdk
  Type: com.vmware.event.router/event
  Subject: UserLoginSessionEvent
  Id: 4256ead8-b86d-4bc0-96ac-92ccaae02605
CloudEvent Data:



Cloud Event
  Source: https://vcenter.cork.local/sdk
  Type: com.vmware.event.router/event
  Subject: UserLogoutSessionEvent
  Id: a160d7bd-542d-4729-98bd-bbb14d505373
CloudEvent Data:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So we can see all events are of the same Type: but the Subject: is populated with descriptive name. The subject contents maps to the vCenter Server event description a list of descriptions by vCenter Server version can be found &lt;a href=&#34;https://github.com/lamw/vcenter-event-mapping&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;creating-a-knative-function&#34;&gt;Creating A Knative Function&lt;/h2&gt;
&lt;p&gt;So we can see it is easy to consume a pre-built function but I wonder how hard it is to create one to meet a bespoke need.  Pleased to report that it turns out that is also pretty easy.&lt;/p&gt;
&lt;p&gt;If we start off by defining problem,  maybe maintaining the synchronicity of state between two systems. When performing ESXi host lifecycle operations it is useful to mark this state in multiple systems. Setting object state to maintenance mode in vCenter Server can trigger vMotion work away from host and prevent scheduling of new workload on host. Setting object state to maintenance mode in vRealize Operations helps reduce amount of false positive issues relating to lifecycle operations. Host lifecycle operations like patching are typically initiated via vCenter Server so its likely maintenance mode will be set enabled and disabled correctly. It might be easy to miss mirroring this operation in vRealize Operations.&lt;/p&gt;
&lt;p&gt;So the first thing we need to do is identify the vCenter Server event created when a host is placed in maintenance mode. Checking the event documentaion we can find the two events are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://vdc-repo.vmware.com/vmwb-repository/dcr-public/fe08899f-1eec-4d8d-b3bc-a6664c168c2c/7fdf97a1-4c0d-4be0-9d43-2ceebbc174d9/doc/vim.event.EnteredMaintenanceModeEvent.html&#34;&gt;EnteredMaintenanceModeEvent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vdc-repo.vmware.com/vmwb-repository/dcr-public/fe08899f-1eec-4d8d-b3bc-a6664c168c2c/7fdf97a1-4c0d-4be0-9d43-2ceebbc174d9/doc/vim.event.ExitMaintenanceModeEvent.html&#34;&gt;ExitMaintenanceModeEvent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we look first at EnteredMaintenanceModeEvent we can create a container image. We can reuse the example Dockerfile and server.ps1 without change.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;## Create folders and pull down reusable example files&lt;/span&gt;
mkdir veba-knative-mm
mkdir veba-knative-mm/enter
mkdir veba-knative-mm/exit
cd veba-knative-mm/enter
curl -O https://raw.githubusercontent.com/vmware-samples/vcenter-event-broker-appliance/master/examples/knative/powershell/kn-ps-echo/Dockerfile
curl -O https://raw.githubusercontent.com/vmware-samples/vcenter-event-broker-appliance/master/examples/knative/powershell/kn-ps-echo/server.ps1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;a href=&#34;https://code.vmware.com/apis/364/vrealize-operations&#34;&gt;vRealize Operations Manager Suite API&lt;/a&gt; shows the two API calls which control Maintenance Mode.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;## Enter Maintenance Mode&lt;/span&gt;
PUT /api/resources/&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;/maintained
DELETE /suite-api/api/resources/&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;id&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;/maintained
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If we look at the object definition for EnteredMaintenanceModeEvent we can see it has properties of event object and extends this with additional maintenance mode related properties. With these details we can update the handler.ps1 script to call vROps API. The &lt;a href=&#34;https://vman.ch/vrops-maintenance-mode-for-resources/&#34;&gt;blog post from vMAN.ch&lt;/a&gt; heavily influenced the following Powershell logic to control maintenance mode state.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Note the following has \ to allow EOF to correctly process $&lt;/span&gt;
cat &amp;lt;&amp;lt;EOF &amp;gt; handler.ps1
&lt;span style=&#34;color:#66d9ef&#34;&gt;Function&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Process&lt;/span&gt;-Handler {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;param&lt;/span&gt;(
      [&lt;span style=&#34;color:#66d9ef&#34;&gt;Parameter&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;Position&lt;/span&gt;=0,&lt;span style=&#34;color:#66d9ef&#34;&gt;Mandatory&lt;/span&gt;=$true)]&lt;span style=&#34;color:#66d9ef&#34;&gt;[CloudNative.CloudEvents.CloudEvent]&lt;/span&gt;$CloudEvent
   )

   Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Cloud Event&amp;#34;&lt;/span&gt;
   Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;  Source: \&lt;/span&gt;$($cloudEvent.Source)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
   Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;  Type: \&lt;/span&gt;$($cloudEvent.Type)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
   Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;  Subject: \&lt;/span&gt;$($cloudEvent.Subject)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
   Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;  Id: \&lt;/span&gt;$($cloudEvent.Id)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
   Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;  Host: \&lt;/span&gt;$($cloudEvent.host)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;

   &lt;span style=&#34;color:#75715e&#34;&gt;# Decode CloudEvent&lt;/span&gt;
   \$cloudEventData = \$cloudEvent | Read-CloudEventJsonData -ErrorAction SilentlyContinue -Depth 10
   &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(\$cloudEventData &lt;span style=&#34;color:#f92672&#34;&gt;-eq&lt;/span&gt; \$null) {
      \$cloudEventData = \$cloudEvent | Read-CloudEventData
   }

   Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;CloudEvent Data:&amp;#34;&lt;/span&gt;
   Write-Host &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\&lt;/span&gt;$(\$cloudEventData | Out-String)&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;
}
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With the Dockerfile and scripts it copies in ready we can look to build the container image locally and then push this to a public container registry.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Build local image with tag for GitHub Container Registry&lt;/span&gt;
docker build --tag ghcr.io/darrylcauldwell/veba-ps-enter-mm:0.1 .

&lt;span style=&#34;color:#75715e&#34;&gt;# Generate GitHub Personal Access Token&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Connect to GitHub Container Registry&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# Use Personal Access Token when prompted for password&lt;/span&gt;
docker login ghcr.io -u darrylcauldwell

&lt;span style=&#34;color:#75715e&#34;&gt;# Push local image to GitHub Container Registry&lt;/span&gt;
docker push ghcr.io/darrylcauldwell/veba-ps-enter-mm:0.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once the container is available in public repository we can look to create a Knative service resource which links to container image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;cat &amp;lt;&amp;lt;EOF &amp;gt; enter-mm-service.yml&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;serving.knative.dev/v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Service&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-ps-enter-mm-service&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-ui&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;vmware-functions&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;template&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;annotations&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;autoscaling.knative.dev/maxScale&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;autoscaling.knative.dev/minScale&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ghcr.io/darrylcauldwell/veba-ps-enter-mm:0.1&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;EOF&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally we can create a Knative trigger resource with filter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;cat &amp;lt;&amp;lt;EOF &amp;gt; enter-mm-trigger.yml&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;eventing.knative.dev/v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Trigger&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-ps-enter-mm-trigger&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-ui&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;vmware-functions&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;broker&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;default&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;filter&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;attributes&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;type&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;com.vmware.event.router/event&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;subject&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;EnteredMaintenanceModeEvent&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;subscriber&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;ref&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;serving.knative.dev/v1&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Service&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;veba-ps-enter-mm-service&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;EOF&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With the manifest files created these can now be applied to create the Pods.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;kubectl apply -f enter-mm-service.yml
kubectl get kservice --namespace vmware-functions
kubectl apply -f enter-mm-trigger.yml
kubectl get triggers --namespace vmware-functions
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;kubectl get pods &amp;ndash;namespace vmware-functions&lt;/p&gt;
&lt;p&gt;NAME                                             READY   STATUS    RESTARTS   AGE
default-broker-ingress-5c98bf68bc-whmj4          1/1     Running   0          4d6h
kn-ps-echo-00001-deployment-6c9f77855c-ddz8w     2/2     Running   0          18m
kn-ps-echo-trigger-dispatcher-7bc8f78d48-5cwc7   1/1     Running   0          18m
sockeye-65697bdfc4-n8ght                         1/1     Running   0          4d6h
sockeye-trigger-dispatcher-5fff8567fc-9v74l      1/1     Running   0          4d6h&lt;/p&gt;
&lt;p&gt;kubectl logs &amp;ndash;namespace vmware-functions kn-ps-echo-00001-deployment-6c9f77855c-ddz8w user-container &amp;ndash;follow&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>VMware Cloud Foundation Lifecycle Management - VCF LCM</title>
      <link>https://darrylcauldwell.github.io/post/vcf-lcm/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://darrylcauldwell.github.io/post/vcf-lcm/</guid>
      <description>
        
          &lt;p&gt;VMware Cloud Foundation provides automated initial deployment and ongoing lifecycle management upgrades. Here I am exploring lifecycle management upgrades and exploring ways to make this as efficient as possible.&lt;/p&gt;
&lt;h2 id=&#34;bundle-download&#34;&gt;Bundle Download&lt;/h2&gt;
&lt;p&gt;The SDDC Manager appliance controls the Cloud Foundation deployment. To upgrade the environment(s) requires the software packages. With each Cloud Foundation release, the required software packages are formed into bundles. The bundles are made available to download to licensed users via their &amp;lsquo;My VMware&amp;rsquo; account.&lt;/p&gt;
&lt;p&gt;There are two methods of downloading the bundles. SDDC Manager can be configured with &amp;lsquo;My VMware&amp;rsquo; account and the LCM service then polls the VMware depot to access update bundles. Alternatively, the Bundle Transfer utility can be used to manually download the bundles from the depot and then upload them to SDDC Manager.&lt;/p&gt;
&lt;p&gt;There is little control and limited UI visibility of bundle downloads using SDDC Manager. This is fine if you advanced plan and configure the account in time to poll available bundles and initiate downloads. The LCM service writes two files that can be useful in understanding progress.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;/var/log/vmware/vcf/lcm/lcm.log
/var/log/vmware/vcf/lcm/lcm-debug.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When you have multiple Cloud Foundation deployments it can be more efficient to use the Bundle Transfer utility to download once and distribute internally. The Bundle Transfer utility is also useful to gain a little more control over the download process.&lt;/p&gt;
&lt;p&gt;The LCM Bundle Transfer utility is shipped with the SDDC Manager appliance. The utility can be used to download various bundle versions. The utility has two elements, to ensure the utility downloads the appropriate bundles for your deployment the first extract environmental metadata from SDDC Manager.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;## SSH to SDDC Manager&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;## Outputs required metadata in files&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;## ~/markerFile&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;## ~/markerFile.md5&lt;/span&gt;

cd /opt/vmware/vcf/lcm/lcm-tools/bin
./lcm-bundle-transfer-util --generateMarker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The second step takes the metadata as input and performs the download. This step requires Java 8 (or later) to be installed but can be run on either Windows or Linux.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;mkdir F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload
scp -rp vcf@nest-1-sddc-manager.cork.local:/opt/vmware/vcf/lcm/lcm-tools F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload
scp -p vcf@nest-1-sddc-manager.cork.local:/home/vcf/markerFile F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload
scp -p vcf@nest-1-sddc-manager.cork.local:/home/vcf/markerFile.md5 F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload
cd F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload&lt;span style=&#34;color:#ae81ff&#34;&gt;\l&lt;/span&gt;cm-tools&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;in
lcm-bundle-transfer-util --download --outputDirectory F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload -depotUser &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;your my.vmware.com username&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; --markerFile F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload&lt;span style=&#34;color:#ae81ff&#34;&gt;\m&lt;/span&gt;arkerFile --markerMd5File F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload&lt;span style=&#34;color:#ae81ff&#34;&gt;\m&lt;/span&gt;arkerFile.md5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once the bundle downloads are complete we can copy them to SDDC Manager and import them into the repository.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;## From Windows device used to download&lt;/span&gt;
scp -pr F:&lt;span style=&#34;color:#ae81ff&#34;&gt;\3&lt;/span&gt;.5.1&lt;span style=&#34;color:#ae81ff&#34;&gt;\b&lt;/span&gt;undleDownload vcf@Snest-1-sddc-manager.cork.local:/nfs/vmware/vcf/nfs-mount/
&lt;span style=&#34;color:#75715e&#34;&gt;## SSH to SDDC Manager and set permissions&lt;/span&gt;
chmod -R &lt;span style=&#34;color:#ae81ff&#34;&gt;0777&lt;/span&gt; /nfs/vmware/vcf/nfs-mount/bundleDownload
cd /opt/vmware/vcf/lcm/lcm-tools/bin
./lcm-bundle-transfer-util --upload --bundleDirectory /nfs/vmware/vcf/nfs-mount/bundleDownload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;update-pre-check&#34;&gt;Update Pre-check&lt;/h2&gt;
&lt;p&gt;Once the bundles are uploaded successfully to the repository we can look towards installing them. Upgrades can fail to apply if the environment isn&amp;rsquo;t healthy. Upgrades can take a while to apply so it is better to avoid failure and rollback. A series of environmental health pre-checks are included which can be run to avoid failure to successfully deploy bundles.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Domain Manager
&lt;ul&gt;
&lt;li&gt;Common services availability check&lt;/li&gt;
&lt;li&gt;Inventory status check&lt;/li&gt;
&lt;li&gt;SDDC Manager VM database data directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM log directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM system directory has enough disk space&lt;/li&gt;
&lt;li&gt;Service availability check&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SDDC Manager UI
&lt;ul&gt;
&lt;li&gt;Inventory status check&lt;/li&gt;
&lt;li&gt;SDDC Manager VM database data directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM log directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM system directory has enough disk space&lt;/li&gt;
&lt;li&gt;Service availability check&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Operations Manager
&lt;ul&gt;
&lt;li&gt;Common services availability check&lt;/li&gt;
&lt;li&gt;Inventory status check&lt;/li&gt;
&lt;li&gt;SDDC Manager VM database data directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM log directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM system directory has enough disk space&lt;/li&gt;
&lt;li&gt;Service availability check&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Platform Services Controllers
&lt;ul&gt;
&lt;li&gt;PSC health&lt;/li&gt;
&lt;li&gt;Credential availability&lt;/li&gt;
&lt;li&gt;Inventory status check&lt;/li&gt;
&lt;li&gt;LCM bundle repo available&lt;/li&gt;
&lt;li&gt;NTP sync&lt;/li&gt;
&lt;li&gt;PSC inventory status check&lt;/li&gt;
&lt;li&gt;PSC SSO connection check&lt;/li&gt;
&lt;li&gt;PSC vmdir service check&lt;/li&gt;
&lt;li&gt;LCM bundle repo free space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM has enough disk space&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NSX Manager
&lt;ul&gt;
&lt;li&gt;Backup availability&lt;/li&gt;
&lt;li&gt;Credential availability&lt;/li&gt;
&lt;li&gt;Enter maintenance dryrun check&lt;/li&gt;
&lt;li&gt;Inventory status check&lt;/li&gt;
&lt;li&gt;LCM bundle repo available&lt;/li&gt;
&lt;li&gt;NSX audit check&lt;/li&gt;
&lt;li&gt;NSX manager inventory status check&lt;/li&gt;
&lt;li&gt;NTP sync&lt;/li&gt;
&lt;li&gt;NSX for vSphere plugin connectivity check&lt;/li&gt;
&lt;li&gt;NSX precheck init&lt;/li&gt;
&lt;li&gt;LCM bundle repo free space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM has enough disk space&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;vCenter
&lt;ul&gt;
&lt;li&gt;vCenter health&lt;/li&gt;
&lt;li&gt;Credential availability&lt;/li&gt;
&lt;li&gt;Inventory status check&lt;/li&gt;
&lt;li&gt;LCM bundle repo available&lt;/li&gt;
&lt;li&gt;NTP sync&lt;/li&gt;
&lt;li&gt;LCM bundle repo free space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM has enough disk space&lt;/li&gt;
&lt;li&gt;vCenter inventory status&lt;/li&gt;
&lt;li&gt;VIM API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Common Services
&lt;ul&gt;
&lt;li&gt;Credential availability&lt;/li&gt;
&lt;li&gt;Inventory status check&lt;/li&gt;
&lt;li&gt;LCM bundle repo available&lt;/li&gt;
&lt;li&gt;NGINX check&lt;/li&gt;
&lt;li&gt;NTP sync&lt;/li&gt;
&lt;li&gt;LCM bundle repo free space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM log directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM system directory has enough disk space&lt;/li&gt;
&lt;li&gt;Service availability check&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;vSAN
&lt;ul&gt;
&lt;li&gt;Advanced configuration sync health&lt;/li&gt;
&lt;li&gt;CLOMD liveness health&lt;/li&gt;
&lt;li&gt;Cluster health&lt;/li&gt;
&lt;li&gt;Encryption health&lt;/li&gt;
&lt;li&gt;HCL age&lt;/li&gt;
&lt;li&gt;HCL health&lt;/li&gt;
&lt;li&gt;Network health&lt;/li&gt;
&lt;li&gt;Object health&lt;/li&gt;
&lt;li&gt;Health summary&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LCM
&lt;ul&gt;
&lt;li&gt;Depot connection&lt;/li&gt;
&lt;li&gt;Depot user&lt;/li&gt;
&lt;li&gt;LCM bundle repo available&lt;/li&gt;
&lt;li&gt;LCM database schema version&lt;/li&gt;
&lt;li&gt;LCM directory permissions&lt;/li&gt;
&lt;li&gt;SDDC Manager VM database data directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM log directory has enough disk space&lt;/li&gt;
&lt;li&gt;SDDC Manager VM system directory has enough disk space&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ESXi Hosts
&lt;ul&gt;
&lt;li&gt;Config check&lt;/li&gt;
&lt;li&gt;Enter maintenance dryrun check&lt;/li&gt;
&lt;li&gt;Inventory status&lt;/li&gt;
&lt;li&gt;NSX sync&lt;/li&gt;
&lt;li&gt;VIM API&lt;/li&gt;
&lt;li&gt;LCM bundle repo available&lt;/li&gt;
&lt;li&gt;LCM bundle repo freespace&lt;/li&gt;
&lt;li&gt;Local filesystem check&lt;/li&gt;
&lt;li&gt;vCenter Connection&lt;/li&gt;
&lt;li&gt;VUM Health&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each check returns health state green, yellow or red if an issue is detected some information on impact and remediation is made available. Sometimes the information returned isn&amp;rsquo;t perfect. The LCM pre-checks output to two files which can be useful in the understanding issue.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;/var/log/vmware/vcf/lcm/lcm.log
/var/log/vmware/vcf/lcm/lcm-debug.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Not all issues require full remediation. In my nested lab environment, the vSAN HCL returns a red issue which can never be resolved. I can either just ignore the error and proceed or we can look to disable the particular check in the configuration.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;vi /opt/vmware/vcf/lcm/lcm-app/conf/application-prod.properties
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;bundle-apply&#34;&gt;Bundle Apply&lt;/h2&gt;
&lt;p&gt;When you are happy with environmental health next to move to apply bundles. To move between Cloud Foundation versions can require applying multiple bundles.  For example, when moving from 3.5.1 to 3.7.1 following bundles are required.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SDDC Manager
&lt;ul&gt;
&lt;li&gt;3.5.1-12050813 to 3.7.0-12696026 (bundle-9775.tar)&lt;/li&gt;
&lt;li&gt;3.7.0-12696026 to 3.7.0-12698020 (bundle-9776.tar)&lt;/li&gt;
&lt;li&gt;3.7.0-12698020 to 3.7.1 (bundle-11811)&lt;/li&gt;
&lt;li&gt;3.7.0-12698020 to 3.7.1 part 2 (bundle-11813)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Management domain
&lt;ul&gt;
&lt;li&gt;NSX 6.4.1 to 6.4.4 (bundle-6712)&lt;/li&gt;
&lt;li&gt;vCenter 6.5 to 6.7.0-10244745 (bundle-6713)&lt;/li&gt;
&lt;li&gt;vCenter 6.7.0-10244745 to vCenter 6.7.0-11726888 (bundle-9777)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Workload domain
&lt;ul&gt;
&lt;li&gt;NSX 6.4.1 to 6.4.4 (bundle-6712)&lt;/li&gt;
&lt;li&gt;vCenter 6.5 to 6.7.0-10244745 (bundle-6713)&lt;/li&gt;
&lt;li&gt;vCenter 6.7.0-10244745 to vCenter 6.7.0-11726888 (bundle-9777)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some of the bundles can take a long time to apply and the UI isn&amp;rsquo;t very verbose. It is very useful to hold an SSH session to SDDC Manager to tail the summary log file to view progress when applying bundles.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;tail -f /var/log/vmware/vcf/lcm/lcm.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The main workflow process spawns other processes so those main upgrade log files sometimes aren’t that verbose and often don’t help identify the issue. It is useful to understand that the spawned processes also log to folder UUID of the bundle apply task. The different bundles create sub-folders and write various logs examples.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;/var/log/vmware/vcf/lcm/upgrades/&amp;lt;upgrade_ID&amp;gt;/thirdparty/sddc-migration-app/logs
/var/log/vmware/vcf/lcm/upgrades/&amp;lt;upgrade_ID&amp;gt;/sddcmanager-migration-app/logs/sddcmanager_migration_app_upgrade.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;skip-level-upgrades&#34;&gt;Skip Level Upgrades&lt;/h2&gt;
&lt;p&gt;As we found before moving between Cloud Foundation versions can lead to applying multiple bundles to the same product. The skip-level upgrade tool was introduced to allow easier uplift to 3.10.1.2 or 3.10.2. For NSX for vSphere based workload domains can uplift to 3.10 from 3.5 and for NSX-T can uplift from 3.7.1.&lt;/p&gt;
&lt;p&gt;Here I am using the skip level upgrade tool to uplift a 3.5.1 NSX-V environment to 3.10.2 some twenty six bundles.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/vcf-lcm-skip-download.png&#34; alt=&#34;Skip Level Download&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;apache-cassandra&#34;&gt;Apache Cassandra&lt;/h2&gt;
&lt;p&gt;The application uses a Apache Cassandra database to store data. When troubleshooting it can be useful to look through the contents.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;## SSH to SDDC manager and open client&lt;/span&gt;
cqlsh --cqlversion&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;3.4.4 127.0.0.1 &lt;span style=&#34;color:#ae81ff&#34;&gt;9042&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;## Get all keyspaces&lt;/span&gt;
describe keyspaces;

&lt;span style=&#34;color:#75715e&#34;&gt;## Change to lcmkeyspace&lt;/span&gt;
use lcmkeyspace;

&lt;span style=&#34;color:#75715e&#34;&gt;## Get all lcmkeyspace tables&lt;/span&gt;
describe tables;

&lt;span style=&#34;color:#75715e&#34;&gt;## Get all host entries from upgrade_activity_log table in json format&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; json * from upgrade_activity_log;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
        
      </description>
    </item>
    
    <item>
      <title>Docker On Photon On vCloud Air</title>
      <link>https://darrylcauldwell.github.io/post/docker-photon/</link>
      <pubDate>Thu, 04 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://darrylcauldwell.github.io/post/docker-photon/</guid>
      <description>
        
          &lt;p&gt;There has been a lot of industry noise around Docker and VMware project Photon so these have been on the agenda to explore as well.  I generally perform my little research projects running nested ESXi on VMware Fusion on my laptop, but VMware are &lt;a href=&#34;http://vcloud.vmware.com/uk/service-offering/virtual-private-cloud-ondemand&#34;&gt;offering £300 of free service credits&lt;/a&gt; for trialing vCloud Air OnDemand.  Here is my how to guide of the steps I used.&lt;/p&gt;
&lt;h2 id=&#34;vcloud-air-networking&#34;&gt;vCloud Air Networking&lt;/h2&gt;
&lt;p&gt;This post assumes your starting with a clean vCloud Air account,  obviously you may already have vCloud Air networking setup,  if so there is no need for this section as long as the Photon and test nexted ESXi VM sit on a common broadcast network this should be fine.&lt;/p&gt;
&lt;p&gt;First task would be to setup a &amp;lsquo;Virtual Private Cloud OnDemand&amp;rsquo; this you create in a location close to you for me thats Slough, UK,  this will create virtual datacenter with &amp;lsquo;default-routed-network&amp;rsquo; (192.168.109.1/24).&lt;/p&gt;
&lt;h2 id=&#34;create-photon-vapp&#34;&gt;Create Photon vApp&lt;/h2&gt;
&lt;p&gt;Surprisingly there is no Photon vApp Template available in the vCloud Air public catalog,  they do however provide the photon-1.0TP1.iso.  So first task is to navigate to vCloud Director, Catalog view and create  new personal Catalog called &amp;lsquo;Photon&amp;rsquo; then navigate to the Public Catalog \ Media tab and copy the Photon ISO to your new personal Catalog.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;While in vCloud Director navigate to My Cloud and &amp;lsquo;Build New vApp&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Within the new vApp add a VM called &amp;lsquo;photon&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Change its OS to &amp;lsquo;Other 3.x Linux (64-bit)&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Increase memory to 2vCPU, 2GB vRAM and vHDD to 40GB&lt;/li&gt;
&lt;li&gt;Change network to &amp;lsquo;default-routed-network&amp;rsquo;, &amp;lsquo;Static - Manual&amp;rsquo; &amp;lsquo;192.168.109.100&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Ensure &amp;lsquo;Organization VDC network&amp;rsquo; is selected and NOT &amp;lsquo;vApp network&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Attach the Photon ISO as CDROM and power on.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;base-photon-configuration&#34;&gt;Base Photon Configuration&lt;/h2&gt;
&lt;p&gt;Open remote console to the Photon VM and it should be at boot menu.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/docker-photon.jpg&#34; alt=&#34;Photon OS&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;From boot menu select Install&lt;/li&gt;
&lt;li&gt;Accept EULA,  and defaults through disk partitioning&lt;/li&gt;
&lt;li&gt;At installation type select &amp;lsquo;3. Photon Full OS (All).&lt;/li&gt;
&lt;li&gt;Give hostname &amp;lsquo;photon.local&amp;rsquo; and give a root password (NextGEN1!)&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;configure-ssh-inbound&#34;&gt;Configure SSH Inbound&lt;/h1&gt;
&lt;p&gt;So next you might not want to use the vCloud Air console to access Photon,  you will probably want to use a SSH client and connect directly.  So to do that we would need to create a &amp;lsquo;Network Address Translation&amp;rsquo; NAT rule to link the vCloud Air externally published IP address with the internal IP address.  There are two types of NAT rule, SNAT and DNAT,  we will be looking to configure DNAT as the traffic is traveling from the Internet (the source) to a virtual machine inside vCloud Air (the destination).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Once booted,  connect to console and logon with root and password.&lt;/li&gt;
&lt;li&gt;Use &lt;a href=&#34;http://www.virten.net/2015/04/basic-commands-for-vmware-photon-and-docker/&#34;&gt;this post&lt;/a&gt; to enable SSH and set static IP address to 192.168.109.100/24 with gateway of 192.168.109.1.&lt;/li&gt;
&lt;li&gt;If we navigate to vCloud Director view &amp;lsquo;Administration&amp;rsquo; tab,  select vDC in the left pane and choose &amp;lsquo;Edge Gateway&amp;rsquo; in the right pane.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/docker-photon-vCD_Gateway.jpg&#34; alt=&#34;vCloud Director Gateway&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Select &amp;lsquo;gateway&amp;rsquo; and select the Action for &amp;lsquo;External IP Allocations&amp;rsquo;,  note down the external IP address.&lt;/li&gt;
&lt;li&gt;Ensure &amp;lsquo;gateway&amp;rsquo; still selected and select the Action for &amp;lsquo;Edge Gateway Services&amp;rsquo;,  change to the NAT tab,  and click &amp;lsquo;Add DNAT&amp;rsquo;,  change applied to to your network add the External IP address as you noted just before,  select port 22 (SSH) for Outgoing and Translated ports,  and give the Photon IP address as the Internal IP.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/docker-photon-Air_NAT.jpg&#34; alt=&#34;vCloud Director NAT&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Ensure &amp;lsquo;gateway&amp;rsquo; still selected and select the Action for &amp;lsquo;Edge Gateway Services&amp;rsquo;,  change to the firewall tab and add ingress firewall rule called SSH-In from external to specific IP 192.168.109.100 port 22.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/docker-photon-Air_FW.jpg&#34; alt=&#34;vCloud Director Firewall&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;If all has gone to plan you should now be able to connect from a remote SSH client.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/docker-photon-Remote_SSH.jpg&#34; alt=&#34;SSH Remote Shell&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;enable-vcloud-air-vm-internet-access&#34;&gt;Enable vCloud Air VM Internet Access&lt;/h2&gt;
&lt;p&gt;To enable our vCloud Air VMs to access the internet we need to configure a NAT rule to handle the private to public address and also a firewall rule to allow the traffic.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add a source NAT rule,  for Original Source enter 192.168.109.0/24 and for Translated Source select your public IP address.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/docker-photon-SNAT.png&#34; alt=&#34;Source NAT&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Add a firewall rule to allow all traffic outbound,  give it name Any-Out,  Source as &amp;lsquo;Internal&amp;rsquo; and destination &amp;lsquo;External&amp;rsquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/docker-photon-FW_Out.png&#34; alt=&#34;Outbound Firewall&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Your Photon VM should now be able to talk to the Internet&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://darrylcauldwell.github.io/images/docker-photon-nslookup.png&#34; alt=&#34;Outbound Connectivity Test&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;
&lt;p&gt;Docker itself is included in the Photon image so with Internet connectivity you can pull things from public repositories and away you go.&lt;/p&gt;

        
      </description>
    </item>
    
  </channel>
</rss>
